---
title: LangGraph
---

# 🦜🕸️LangGraph.js

⚡ 构建具有 LLM 的语言代理作为图 ⚡

## 概述

LangGraph 是一个用于构建具有 LLM 的状态多角色应用的库，建立在[LangeChain.js](https://github.com/langchain-ai/langchainjs)之上，并旨在与它一起使用。
它扩展了[LangeChain 表达式语言](/docs/expression_language/)，增加了在循环方式下协调多个链（或角色）跨多个计算步骤的能力。
它受到[Pregel](https://research.google/pubs/pub37252/)和[Apache Beam](https://beam.apache.org/)的启发。
当前接口是受[NetworkX](https://networkx.org/documentation/latest/)启发的。

主要用途是为您的 LLM 应用程序添加**循环**。
重要的是，LangGraph 并不仅仅针对**DAG**工作流进行优化。
如果您想构建 DAG，您应该只使用[LangeChain 表达式语言](/docs/expression_language/)。

循环对于类似代理的行为非常重要，在这种行为中，您在循环中调用 LLM，询问它下一步要采取什么行动。

> 寻找 Python 版本？点击[这里](https://github.com/langchain-ai/langgraph)。

## 安装

```bash
npm install @langchain/langgraph
```

## 快速开始

LangGraph 的一个核心概念是状态。每个图执行都会创建一个状态，在图中的节点执行时在它们之间传递，每个节点执行后都会用其返回值更新这个内部状态。图如何更新其内部状态由选择的图类型或自定义函数定义。

LangGraph 中的状态可以相当通用，但为了简化入门，我们将展示一个将图的状

## 文档

这里只有一些新的 API 可以使用。

### StateGraph

主要的入口点是`StateGraph`。

```typescript
import { StateGraph } from "@langchain/langgraph";
```

这个类负责构建图形。它提供了一个受[NetworkX](https://networkx.org/documentation/latest/)启发的接口。这个图由一个状态对象参数化，该对象在各个节点之间传递。

#### `constructor`

```typescript
interface StateGraphArgs<T = any> {
  channels: Record<
    string,
    {
      value: BinaryOperator<T> | null;
      default?: () => T;
    }
  >;
}

class StateGraph<T> extends Graph {
  constructor(fields: StateGraphArgs<T>) {}
}
```

在构建图形时，你需要传递一个状态的模式。然后每个节点返回更新该状态的运算。这些运算可以设置状态的特定属性（例如，覆盖现有值）或添加到现有属性。是否设置或添加由你在构建图形时注明的状态对象决定。

让我们看一个例子：

```typescript
import { BaseMessage } from "@langchain/core/messages";

const schema = {
  input: {
    value: null,
  },
  agentOutcome: {
    value: null,
  },
  steps: {
    value: (x: Array<BaseMessage>, y: Array<BaseMessage>) => x.concat(y),
    default: () => [],
  },
};
```

我们可以这样使用它：

```typescript
// 使用这个状态初始化StateGraph
const graph = new StateGraph({ channels: schema })
// 创建节点和边
...
// 编译图形
const app = graph.compile()

// 输入应该是一个对象，因为模式是一个对象
const inputs = {
   // 假设这是输入
   input: "hi"
   // 假设agent_outcome在某个时候由图形设置
   // 它不需要被提供，默认为null
}
```

### `.addNode`

```typescript
addNode(key: string, action: RunnableLike<RunInput, RunOutput>): void
```

这个方法向图形中添加一个节点。它接受两个参数：

- `key`: 表示节点名称的字符串。这必须是唯一的。
- `action`: 在调用这个节点时要采取的动作。这应该是一个函数或一个可运行的。

### `.addEdge`

```typescript
addEdge(startKey: string, endKey: string): void
```

从第一个节点创建一个边到下一个节点。这意味着第一个节点的输出将传递给下一个节点。它接受两个参数。

- `startKey`: 表示开始节点名称的字符串。这个键必须在图形中已经注册。
- `endKey`: 表示结束节点名称的字符串。这个键必须在图形中已经注册。

### `.addConditionalEdges`

```typescript
addConditionalEdges(
  startKey: string,
  condition: CallableFunction,
  conditionalEdgeMapping: Record<string, string>
): void
```

这个方法添加条件边。这意味着只有一个下游边会被采取，哪一个取决于开始节点的结果。这接受三个参数：

- `startKey`: 表示开始节点名称的字符串。这个键必须在图形中已经注册。
- `condition`: 调用来决定接下来做什么的函数。输入将是开始节点的输出。它应该返回一个在`conditionalEdgeMapping`中存在的字符串，表示要采取的边。
- `conditionalEdgeMapping`: 字符串到字符串的映射。键应该是`condition`可能返回的字符串。值应该是如果返回该条件，要调用的下游节点。

### `.setEntryPoint`

```typescript
setEntryPoint(key: string): void
```

图形的入口点。这是首先调用的节点。它只接受一个参数：

- `key`: 应首先调用的节点的名称。

### `.setFinishPoint`

```typescript
setFinishPoint(key: string): void
```

这是图形的出口点。当调用这个节点时，结果将是图形的最终结果。它只有一个参数：

- `key`: 当调用这个节点时，将返回其调用结果的最终输出的节点的名称。

注意：如果你之前创建了一个边（条件或正常）到`END`，则不需要调用这个。

### `END`

```typescript
import { END } from "@langchain/langgraph";
```

这是一个特殊的节点，表示图形的结束。这意味着传递给这个节点的任何东西都将是图形的最终输出。它可以在两个地方使用：

- 作为`addEdge`中的`endKey`
- 作为传递给`addConditionalEdges`的`conditionalEdgeMapping`中的一个值

## 示例

### AgentExecutor

请参见上面的快速开始，了解如何重新创建 LangChain 的[`AgentExecutor`](/docs/modules/agents/concepts#agentexecutor)类。

### 强制函数调用

对上述图形的一个简单修改是修改它，使得一个特定的工具总是首先被调用。如果你想要强制调用一个特定的工具，但仍然想在之后启用代理行为，这可能会
